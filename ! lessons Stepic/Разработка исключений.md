## Пользовательские исключения

Чтобы создать собственное исключение, нужно создать класс, который является наследником одного из [существующих исключений](Обработка%20исключений.md) (обычно `Exception`). 

``` python
class NegativeAgeError(Exception):
    pass

try: 
    print('Введите свой возраст') 
    age = int(input()) 
    if age < 0: 
        raise NegativeAgeError('Возраст не может быть отрицательным')
    print('Ваш возраст равен', age) 
except ValueError: 
    print('Возраст должен быть числом') 
except NegativeAgeError as e:
    print(e)

```

Получаем что:
- Value error - при нечисловых значениях 
- NegativeAgeError - при отрицательных значениях

## Методики разработки исключений

### LBYL

LBYL (Look Before You Leap) - посмотри перед прыжком

Перед выполнением действия, удостоверяемся, что ничего плохого не случится

### EAFP 

EAFP (Easier to Ask Forgiveness than Permission) - проще извиниться, чем спрашивать разрешения

Выполняем действие, если возникла ошибка - обрабатываем, иначе идем дальше

Пример
``` python

data = {'Timur': 29, 'Ivan': 54} 

# LBYL
if 'Anri' in data: 
    data['Anri'] += 1 
else: 
    print('Ключ Anri отсутствует в словаре.')

# EAFP
try:
    data['Anri'] += 1
except KeyError:
    print('Ключ Anri остсутствует в словаре')
```

В Python, скорее, преобладает подход EAFP.

Замечания:
1. **Читаемость**. EAFP более читаем, так как мы не перегружаем код проверками.
2. **Производительность.** Если одна ошибка может привести ко многим ошибкам, которые нужно будет отдельно проверять, то предпочтительнее использовать LBYL. Иначе, если ошибки появляются редко, то проще обработать ошибку, чем запускать проверку условий.  То есть в каких то случаях предпочтительнее LBYL, в каких то EAFP.
3. **Повторяющиеся проверки**. EAFP позволяет избегать ненужный проверок, так как многие их них реализованы в методах Python. Например, функция `int()` уже имеет внутреннюю проверку состоит ли строка только из цифр, иначе вызовет исключение. Запускать метод `isdigit()` излишне, так как он уже реализован в `int()`, к тому же `isdigit` будет браковать отрицательные числа.
4. **Если действия нужно откатить обратно**. EAFP принимается за выполнение кода без предварительных проверок, что может быть плохо, если нам нужно будет откатиться обратно к моменты до вызова ошибки. В LBYL все сначала проверяет, следовательно, такой проблемы нет.
5. **Риск состояния гонки**. В момент выполнения кода контекст может изменится, то есть проверка может потратить тот момент времени, когда условия действительно было истинно, а на момент запуска фрагмента программы условие стало уже ложно.  Например, при доступе к базе данных. 