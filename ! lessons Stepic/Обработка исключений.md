Типы ошибок: 
- Синтаксические (ошибки синтаксиса - отлавливаются интерпретатором)
- Логические (ошибка в логике программы. Например, функция возвращает неожиданный результат при верных входных данных)
- Ошибки времени выполнения (исключения) (например, неверные входные данные)

Сначала определяются синтаксические, затем логические, потом исключения

Работа с исключениями в Python реализована через механизм исключений, в других более ранних языках использовании механизм кодов возврата.

## Try/except

``` python
try: 
    # контролируемый код 
except тип_ошибки_1: 
    # код обработки ошибки (исключения)
except тип_ошибки_2: 
    # код обработки ошибки (исключения) 
# ... 
except тип_ошибки_n:
# код обработки ошибки (исключения) 
else: 
    # код для случая, если ошибки не было
finally: 
    # код, который выполняется всегда
```

**else**: Подобен работе `else` в конструкциях `for/while`.  Он срабатывает, если не возникло ошибок в контролируемом коде (если тело цикла завершилось штанным способом, без break)

**finally**: 
1. срабатывает независимо от выполнения блоков `except`.
2. Может использоваться без блоков `else` и `except`.
3. Если возникло необработанное исключение, то он все равно будет выполнен. Действия: произошла необработанная ошибка, выполнился блок `finally`, управление переходит обработчику более высокого уровня, который прерывает выполнение программы и выводит сообщение об ошибке. 
4. Будет выполнен даже при срабатывании `break`, `continue`, `return`.
5. Возврат из функции будет происходить из блока `finally` даже при наличии `return` в блоке `try`. Так как блок `finally` выполняется до `return` расположенного в `try`.
6. Если в `try` использован `return`, то `return` начнет ссылаться на объект который должен вернуть (не на переменную).    

``` python
# 2.
try: 
    х = 10 / 0 
finally: 
    print('Блoк finally')

# 4.
def tt():
    try:
        int(1)
        return 10
    except:
        print('No')
    finally:
        print('I am here')
        return 20
print(tt()) 
# I am here
# 20

# 5. 
def f():
    try:
        x = 10
        return x
    finally:
        x = 20
print(f()) # 10 

def f():
    try:
        x = [10]
        return x
    finally:
        x.append(20)
print(f()) # [10, 20]

```


Пример использования `finally`
``` python
try: 
    file = open('data.txt', encoding='utf-8') 
    try: 
        text = file.read()
    except: 
        print('При чтении из файла произошла ошибка!') 
    else: 
        print('Чтение из файла прошло успешно!') 
    finally: 
        file.close() 
except FileNotFoundError: 
    print('Файл с указанным именем не найден!')
```

При возникновении ошибки в блоки try, будет происходить последовательный просмотр *except* блоков. Если тип ошибки совпадет с типом указанным в блоке, то этот блок будет выполнен. Если не один *except* блок не будет выполнен, то программа будет остановлена. 

``` python
try: 
    num1 = int(input()) 
    num2 = int(input()) 
    print('Частное чисел равно', num1 / num2)
except (ValueError, IndexError, KeyError) as e: # Можно использовать аллиас 
    print('Тут обрабатываются сразу три типа ошибок!')
except ZeroDivisionError: 
    print('На ноль делить нельзя!')
except: # блок без указания типа ошибки должен быть только один, иначе SyntaxError
    print('Если не сработал ни один из предыдущих блоков except.') 
print('Работа программы завершена!')
```

Основные типы исключений:
- `IndexError`: возникает, когда индекс (например, для элемента списка) указан неправильно (выходит за границы допустимого диапазона)
- `KeyError`: возникает при неверно указанном ключе словаря
- `NameError`: возникает, если не удается найти переменную с некоторым названием
- `SyntaxError`: возникает при наличии в исходном коде синтаксических ошибок
- `TypeError`: возникает при несоответствии типов, когда для обработки требуется значение определенного типа, а передается значение другого типа
- `FileNotFoundError`: возникает при открытии несуществующего файла
- `ValueError`: возникает, когда в функцию передается аргумент с неподдерживаемым значением
- `ZeroDivisionError`: возникает при попытке выполнить деление на ноль


> [!NOTE] ValueError / TypeError
> TypeError - операция или функция применяется к объекты неподходящего типа
> Пример: `'hello' + 2
> `
> ValueError - функция или операция получает аргумент правильного типа, но не с неподходящим значением
> Пример: `int('hello')`


> [!NOTE] Особенность работы блока try
> Обработчик исключений обрабатывает исключения во всех объектах находящихся в блоке
> `try`, даже, если мы вызываем в эотм блоке функцию

``` python
def this_fails(): 
    num = 1 / 0 
try: 
    this_fails() 
except ZeroDivisionError: 
    print('Деление на ноль')
```


![](Структура_исключений.png)

![Заглушки](Заглушки.md)


> [!NOTE] Важно
> Тип `Exception` - базовый класс для большинства встроенных в Python исключений

Обработчик исключений может поймать не только указанные типы исключений, но и всех их потомков. Возвращает кортеж: тип исключения, экземпляр исключения, содержащий информацию об ошибке, объект с трассировочной информацией об исключении, которое в данный момент обрабатывается.

Для получения информации об исключении используем `sys.exc_info()`.
``` python
from sys import exc_info 
try:
    х = 1 / 0 
except Exception as err: 
    print(exc_info())
# (<class 'ZeroDivisionError'>, ZeroDivisionError('division by zero'), <traceback object at 0x000001BEEF80E840>)
```

Таблица основных типов исключений.

| Тип исключения        | Описание                                                                                                                                                                          |
| --------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `BaseException`       | является классом самого верхнего уровня и базовым для всех прочих  <br>классов исключений                                                                                         |
| `Exception`           | базовый класс для большинства встроенных в Python исключений. Именно  <br>его, а не `BaseException`, необходимо наследовать при создании пользовательского класса  <br>исключения |
| `AssertionError`      | возбуждается инструкцией `assert`                                                                                                                                                 |
| `AttributeError`      | возбуждается при попытке обращения к несуществующему атрибуту объекта                                                                                                             |
| `EOFError`            | возбуждается функцией `input()` при достижении конца файла с вводными данными                                                                                                     |
| `ImportError`         | возбуждается, если невозможно импортировать модуль или пакет                                                                                                                      |
| `IndexError`          | возбуждается при попытке получить элемент коллекции по несуществующему индексу                                                                                                    |
| `KeyError`            | возбуждается при попытке получить элемент коллекции по несуществующему ключу                                                                                                      |
| `MemoryError`         | возбуждается, если интерпретатору существенно не хватает оперативной памяти                                                                                                       |
| `NameError`           | возбуждается при попытке обратиться к необъявленной переменной                                                                                                                    |
| `TypeError`           | возбуждается при несоответствии типов                                                                                                                                             |
| `ValueError`          | возбуждается при передаче в функцию аргумента с неподдерживаемым значением                                                                                                        |
| `ZeroDivisionError`   | возбуждается при попытке выполнить деление на ноль                                                                                                                                |
| `NotImplementedError` | возбуждается, если наследник класса не переопределил метод, который должен был переопределить                                                                                     |
## Возбуждение исключений

Для возбуждения используем оператор `raise`. Аргумент оператора - это экземпляр класса, унаследованный от `Exception`. Класс указывает на тип исключения, а аргумент, передаваемый конструктору этого исключения описывает подробности возникновения исключительной ситуации. 

Если возбуждаемые пользователем исключения не перехватываются, то они распространяются вплоть до стандартного обработчика ошибок и прекращают работы программы.

``` python
try: x, y = 10, 0 
    if y == 0: 
        raise ZeroDivisionError('Произошло деление на ноль.')
except ZeroDivisionError as err: 
    print(err) 
    print(err.args)
    # Произошло деление на ноль.
    # ('Произошло деление на ноль.',)
```

#### Варианты использования `raise`:

1.  `raise`  <экземпляр класс>
``` python
raise ValueError('Definiton error')
```
2. `raise`  <название класса>
``` python
raise ValueError # raise ValueError()
```
3. `raise`  <экземпляр или название класса> `from` <объект исключения>
    Указывается экземпляр или название класса, затем объект исключения, на основании которого будет вызвано исключение. В этом случаем это исключение будет записано в атрибут `__cause__`. Эти данные могут быть использованы для поиска места первоначального исключения
``` python
try: 
    х = 1 / 0 
except Exception as err:
    raise ZeroDivisionError('Описание исключения') from err    
```
4. `raise` 
    Происходит повторное возбуждение исключения, то есть перебрасывание его выше.
``` python
try:
    try:
        х = 1 / 0
    except Exception as err:
        raise # пробрасываем (добавляем err)
finally:
    pass
```
Вывод: 
```
File "c:/Users/koval/projects/solveTasks/as.py", line 3, in \<module>         
х = 1 / 0
```
Второй вариант: 
```
c:/Users/koval/projects/solveTasks/as.py", line 5, in \<module>
    raise err
  File "c:/Users/koval/projects/solveTasks/as.py", line 3, in \<module>
    х = 1 / 0
```


> [!NOTE] Важно
> Механизм исключений работает медленно, поэтому не рекомендуется его использовать слишком часто (например, в циклах)

## Полезные ресурсы:
* [Статья](https://nedbatchelder.com/text/names.html) об устройстве переменных в Python 
* [Шаг на степик](https://stepik.org/lesson/656891/step/1?unit=653974)
* [Реализация собственных исключений](https://habr.com/ru/companies/piter/articles/537642/)
* [Module Traceback](Module%20Traceback.md)
* [Профессионально обрабатываем исключения в Python](https://habr.com/ru/companies/otus/articles/570882/)