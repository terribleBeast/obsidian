#TODO
## 1. Типизация языков программирования 

**Типизация языков программирования** - это то, как различные языки распознают типы переменных 
ЯП бывают:
- Типизированными 
- Нетипизированными (бестиповыми)
### Нетипизированными языки программирования
Все данные в этих языках считаются цепочками бит произвольной длины, который не делятся не типы. 
##### Преимущества:
- написание программ на предельно низком уровне
- нет проверки типов
- возможность проведения операция над любыми типами данных
- получаемый код обычно более эффективен
- прозрачность инструкции (низкий уровень абстракции)
##### Недостатки:
- сложность при работе с типами данными, так как их нельзя отличить друг от друга
- отсутствие проверок типов, следовательно, сложнее отловить ошибки
- низкий уровень абстракции

Примеры: Assembler, Forth, Brainfuck.

### Типизированные языки программирования 

Категории:
- статическая и динамическая
- сильная (строгая) и слабая (нестрогая)
- явная и неявная
#### Статическая и динамическая типизация

В ЯП со статическая типизацией проверка типов начинается на стадии компиляции. Благодаря этому программы на таких ЯП обычно производительнее.

В ЯП с динамической типизацией ищут ошибки на стадии выполнения. В них можно задать разные типы для одной и той же переменной. 

##### Преимущества статической типизации:
- проверка типов происходит только один раз - на этапе компиляции;
- более высокая скорость выполнения, в сравнении с динамической типизации;
- ускорение разработки при использовании IDE.
##### Преимущества динамической типизации:
- простота создания универсальных коллекций;
- удобство описания обобщенный алгоритмов;
- легкость в освоении.

Примеры:
- статической: C, C#, Java, GO, Kotlin
- динамической: Python, JavaScript, Ruby
#### Сильная и слабая типизация

В слабо типизированных языках для операторов можно применять разные типы данных, так как они будут неявно преобразованы к единому типу.

В ЯП с сильной типизацией разрешено выполнять операции только с переменными одного типа.

##### Преимущества сильной:
- надежность: получение ошибки компиляции при использовании разных типов;
- скорость: отсутствие скрытых преобразований;
- понимание работы программы: программисту необходимо сделать все преобразования вручную;
- определенность: мы знаем какого типа переменные будут использованы.
##### Преимущества слабой типизации:
- возможность использования смешанных выражении;
- абстрагирование от типизации и сосредоточение на задаче;
- краткость записи.

Примеры:
- сильной: Java, Python, Lisp, Haskell
- слабая: C, JavaScript, PHP
#### Явная и неявная типизация

В ЯП с явной типизацией необходимо явно задавать типы переменных. 
``` c#
int data = 17;
```
В ЯП с неявной типизацией тип переменной определяется интерпретатором или компилятором, поэтому запись выглядит короче.
``` python
data = 17
```

##### Преимущества явной типизации:
- указание типа при каждой переменной или функции, значит, можно легко понять какой тип данных используют выражения;
- легкость в определении типа данных, которые записаны в переменной.
##### Преимущества неявной типизации
- сокращенная запись;
- устойчивость к изменениям: при изменении типа входного параметра функции нет необходимости переписывать тип переменной, в которой будут использованы данные входного параметра.

## Примечания

**Примечание 1.** Python — это язык с **динамической, сильной и неявной** типизацией. Такая система типов — это очень удачный компромисс между простотой разработки и надежностью написанных программ.

**Примечание 2.** Отличная статья о типизации языков программирования доступна по [ссылке](https://habr.com/ru/post/161205/)
**Примечание 3.** О типизации языков программирования также можно почитать по [ссылке](http://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85).

**Примечание 4.** Многие статические языки программирования позволяют использовать динамическую типизацию:

- C# поддерживает псевдо-тип dynamic
- F# поддерживает синтаксический сахар в виде оператора ?, на базе чего может быть реализована имитация динамической типизации
- Haskell — динамическая типизация обеспечивается модулем Data.Dynamic
- Delphi — посредством специального типа Variant
- С++ использует auto.

## 2. Аннотации типов 

В Python 3.5 появились аннотации типов [PEP484](https://peps.python.org/pep-0484/), использовать можно было только при объявлении параметров функций и возвращаемых значений. В версии 3.6 эта возможность была расширена - стало можно объявлять типы переменных в любом месте программы [PEP526](https://peps.python.org/pep-0526/). 

Использовании аннотаций никак не влияет на скорость выполнения кода, только на его читаемость. Python никак не использует эту информацию он лишь перекладывает её в специальные атрибуты функций или переменных, делая доступной для сторонних утилит. Получается, что можно передать в функцию, принимающую строку, число не вызвав при этом ошибки.

Стандартные типы: `int`, `float`, `str`, `NoneType`, `bool`.
Стандартные типы коллекций: `set`, `list`, `tuple`, `dict`.

Для указания типов элементов коллекция в Python < 3.9 нужно было использовать типы из модуля `typing`.
``` python
from typing import List 

def sum_square(nums: List[int]) -> int: 
    total = 0 
    for i in nums: 
    total += i ** 2 
    
    return total
```
С 3.9
``` python
numbers: list[int] # тип всех элементов списка 
person: tuple[str, int, bool] # тип каждого элемента кортежа 
prices: dict[str, int] # тип ключей, тип значений 
answers: set[float] # тип всех элементов множества
```

Доступ к аннотациям можно получить через атрибут `__annotations__`.
``` python
def avg(num1: int, num2: int, num3: int) -> float: 
    return (num1 + num2 + num3) / 3 

print(avg.__annotations__)

# {'num1': <class 'int'>, 'num2': <class 'int'>, 'num3': <class 'int'>, 'return': <class 'float'>}
```
## 3. Полезные типы модуля `typing`

#### Union

Функция может корретно работать с несколькими типами одной переменной.

``` python
from typing import 

Union NumberOrStr = Union[int, float, str] 

def add_or_concatenate(a: NumberOrStr, b: NumberOrStr) -> NumberOrStr: 
    return a + b
```

#### Optional

Функция принимает значения определенного типа либо `None`.

``` python
from typing import Union, Optional 

name: Union[str, None]
# или
name: Optional[str]
```
#### Any

Когда не удается указать конкретный тип, потому что функция будет корретно работать при любом типе входного параметра.


``` python
from typing import Any 

def func(arg: Any) -> Any: 
    return arg
```
Использовать только в исключительных случаях.

#### NoReturn

Указывает, что функция никогда не возвращает значение.

``` python
from typing import NoReturn

def stop() -> NoReturn:
    raise RuntimeError('no way')
```

`None` и `NoReturn` - разное


## Ресурсы

**Примечание 1.** Документация модуля `typing` доступна по [ссылке](https://docs.python.org/3/library/typing.html).

**Примечание 2.** В Python 3.10 вместо записи `Union[X, Y]` можно писать `X | Y`.

**Примечание 3.** В экосистеме Python есть несколько конкурирующих между собой тайп-чекеров, например, [`mypy`](http://mypy-lang.org/), [`pyre`](https://pyre-check.org/), [`pytype`](https://github.com/google/pytype), [`pyright`](https://github.com/Microsoft/pyright). Данные тайп-чекеры позволяют находить ошибки связанные с несоответствием типов еще на этапе написания программы. Самым популярным среди них является `mypy`, автором которого является Гвидо ван Россум.

**Примечание 4.** На странице ["Awesome Python Typing"](https://github.com/typeddjango/awesome-python-typing) можно найти много полезных инструментов, которые используют аннотации типов.

