---
tags:
  - Python
  - "#processing"
---
---
Дата создания: 2024-11-14 17:56
Дата последнего изменения: 
---
## Основные идеи

1) Итераторы выдают по одному значению
2) Хранят текущее, конечное значение и шаг.
3) Занимают 48 байт
4) Могут замедлять скорость выполнения программы.

---

**Итераторы** - объекты, которые "выдают" значения по одному. Хранят только текущее и последние значение. Занимают 48 байт. Для следующего значения - `next()`, иначе исключение `StopIteration`. Если для формирования следующего элемента используется сложная логика, то итераторы могут замедлить скорость выполнения программы.

`next(collection, stop_element)` `stop_elemet` - элемент, после которого будет возбуждено исключение

[Коллекция](Коллекция.md)
Преимущества итераторов: 
- однотипность работы с разными объектами разных типов 
- ленивые вычисления и экономия памяти
- комбинация множества итераторов для создания понятной и читабельной программы

## Однотипность работы с объектами разных типов

Итераторы позволяют одинакового работать с объектами разных типов.
При преобразовании итераторов в другие типы происходит его обход и, как следствие, опустошение.

``` python
numbers = [-3, 6, 1, -90, 34, -25, 23, -21]
positive_numbers = map(abs, numbers) # создаем объект итератора
positive_numbers_list1 = list(positive_numbers) # преобразуем итератор в список 
positive_numbers_list2 = list(positive_numbers) # преобразуем пустой итератор в список


print(positive_numbers_list1) # [-3, 6, 1, -90, 34, -25, 23, -21]
print(positive_numbers_list2) # []
```

Аналогично происходит и с оператором `in`.

> [!NOTE] Оператор `for`
> `for` создает итератор на основе итерируемого объекта, запрашивает очередной элемент с помощью функции `next` и передает в выполняемый блок кода, останавливает цикл при генерации исключения `StopIteration`

## Ленивые вычисления и экономия потребляемой памяти

Ленивые вычисления предполагают, что не нужно ничего делать до тех пор, пока в этом нет необходимости. 
``` python
numbers = range(5)

for num in numbers:
    print(num)
```

Объекты типа `range` являются итерируемыми объектами. Цикл `for` создает на основе объекта `range` итератор, у которого запрашивает элементы по одному, пока не будет достигнут конец последовательности чисел. В нашем примере, пока не будет получено число 44.

Объект `range` не хранит весь набор чисел. Он создает новое число (на лету) только, когда оно потребуется, при этом старые значения не хранятся. Размер объектов `range` не зависит от количества чисел, которые предполагается перебрать, ведь нужно помнить только начальное и конечное значения последовательности, шаг и текущее значение.

``` python
from sys import getsizeof 

numbers1 = range(5) # 5 чисел в последовательности 

numbers2 = range(100000) # 100000 чисел в последовательности 
numbers3 = range(10000000000000) # 10000000000000 чисел в последовательности

print(getsizeof(numbers1)) # 48
print(getsizeof(numbers2)) # 48
print(getsizeof(numbers3)) # 48
```

Занимаемый размер 48 байт. Такой подход позволяет создавать "большие" итераторы (даже бесконечные, не занимая много памяти

``` python
from sys import getsizeof 
numbers3 = list(range(10000000000000)) # 10000000000000 чисел в списке

print(getsizeof(numbers3)) # исключение MemoryError
```
## Комбинации множества итераторов

Комбинация итераторов позволяет уменьшить объем кода и объем необходимой памяти. 

``` python
sentence = 'In the face of ambiguity refuse the temptation to guess'
filter_iterator = filter(lambda word: len(word) > 4, sentence.split()) # фильтруем
map_iterator = map(lambda word: word.upper(), filter_iterator) # преобразовываем 
enumerate_iterator = enumerate(map_iterator, 1) # нумеруем 

for index, value in enumerate_iterator: # выводим 
    print(f'{index}. {value}')
```

## Протокол итерируемых объектов и итераторов


> [!NOTE] Title
> Чтобы объект был итерируемым, он должен иметь атрибуты `__getitem__` и `__len__`.

> [!NOTE] Title
> Каждый итератор имеет методы `__iter__` и `__next__`.


1. чтобы получить итератор, мы должны передать функции `iter()` итерируемый объект
2. далее мы передаём итератор функции `next()`
3. когда элементы в итераторе закончились, вызов функции `next()` возбуждает исключение `StopIteration`

Особенности
1. любой объект, передаваемый функции `iter()` без исключений `TypeError` - итерируемый объект
2. любой объект, передаваемый функции `next()` без исключений `TypeError` - итератор
3. любой объект, передаваемый функции `iter()` и возвращающий себя - итератор.


## Особенность функции `iter()`

Использование в "роли" цикла `while`.
Синтаксис `iter(callable, sentinel) -> iterator`

Если функции `iter()` передается два аргумента, то первый аргумент `callable` должен являться функцией, которая не принимает аргументов, а второй аргумент `sentinel` — некоторым стоп-значением. В этом случае, созданный итератор будет вызывать указанную функцию `callable` и проверять полученное значение на равенство со значением `sentinel`. Если полученное значение равно `sentinel`, то возбуждается исключение `StopIteration`, иначе итератор выдает значение, полученное из функции `callable` (обратим внимание, что цикл `for` обрабатывает это исключение).

``` python
from random import choice 

def test_iter(): 
    values = list(range(1, 11)) 
        return choice(values) 
        
random_iterator = iter(test_iter, 2) 

for num in random_iterator: 
    print(num)


with open('data.txt') as file: 
    for line in iter(file.readline, ''): # читаем, пока не попадется пустая строка 
        # Делаем что-то с line.
        pass
```



## Примечания 
1) Функция `len` может не работать с некоторыми итераторами, так как их длина может быть очень большой.
2) Для некоторых итерируемых объектов длину можно посчитать почти мгновенно, не перебирая элементы, например `range`.
3) `iterator` и `iterable` - разные понятия
4) В Python есть встроенный модуль `collections.abc`, который предоставляет абстрактные базовые классы различного типа коллекций. Изучите данный модуль по [ссылке](https://docs.python.org/3/library/collections.abc.html).

![](Pasted%20image%2020241116192415.png)
---
## Ресурсы:
1) [раз](https://habr.com/ru/articles/337314/)
2) [два](https://realpython.com/python-iterators-iterables/)
3) [Поколение 1](https://stepik.org/lesson/668458/step/1?unit=666568)
4) [Поколение 2](https://stepik.org/lesson/668595/step/1?unit=666704)
5) [Комментарий об модуле `collections.abs`](https://stepik.org/lesson/668595/step/1?discussion=10283479&unit=666704)
6) [Примеры итераторов (Поколение)](https://stepik.org/lesson/669733/step/1?unit=667881)Возможно что то добавить отсюда
