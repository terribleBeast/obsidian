
### [Built in function](https://docs.python.org/3/library/functions.html#all)
**Функция** - это объект. Функцию можно передавать в другие функции, присваивать переменным.
```python
def start(): # тело функции start 
	pass 
def stop(): # тело функции stop 
	pass 
def pause(): # тело функции pause 
	pass

commands = {'start': start, 'stop': stop, 'pause': pause} # словарь соответствия команда → функция
command = 'start' # считываем название команды
commands[command]() # вызываем нужную функцию через словарь по ключу

```
>[!note] Компаратор (от англ. compare - сравнивать)
>Функция, определяющая условия сравнения элементов.

### Функции высшего порядка

Функция высшего порядка - функция, которая либо принимает одна или несколько функций в качестве аргументов, либо возвращает функцию в качестве своего результата. 

Встроенные функции высшего порядка:
[[map]] - преобразование элементов списка;
[[filter|filter]] - фильтрация элементов списка;
[[reduce|reduce]] - [[агрегация]] элементов списка.


> [!NOTE] ~~Костлявая~~ Могучая рука C
> Функции `map` и `filter` написана на C и хорошо оптимизированы, их внутренний цикл более эффективный, чем обычный цикл `for` в Python


> [!NOTE] Потребление памяти
> `map` и `fitler` потребляют мало памяти, так как элементы последовательности извлекаются по запросы, следовательно, в памяти системы находится и обрабатывается только один элемент последовательности.



Модуль [[operator]]

Хороший комментарий по [итераторам](https://stepik.org/lesson/511145/step/1?discussion=5541612&unit=503343)

## Анонимные функции

>[!note]
> **Анонимная функция** - функция с телом, но без имени.
> 
> Synt: lambda список_параметров: выражение
> Параметры через запятую

#### Передача аргументов
* позиционные аргументы;
- именованные аргументы;
- переменный список позиционных аргументов (`*args`);
- переменный список именованных аргументов (`**kwargs`);
- обязательные аргументы (`*`).

Применение:
* однократное использование  функции;
* передача функций в качестве аргументов другим функциям;
* возвращение функции в качестве результата другой функции;
* может быть использована для выполнения рекурсии.

Особенности:
* анонимная функция может содержать только выражение, и может не включать в свое тело [[Оператор|операторов]];
* в теле анонимной функции такие операторы, как return, pass, asser или raise вызовут исключение SyntaxError;
* анонимная функция пишется как одна строка исполнения;
* анонимная функция может быть немедленно вызвана;
* часто анонимные функции называют просто "лямбдами";
* В Python лямбда имеет тип "функция", поэтому лямбды это просто сокращенная запись обычный функций;

Примеры:

1.  Компаратор
```python
numbers = [1, 2, 3, 4, 5, 6] 
new_numbers1 = list(map(lambda x: x+1, numbers)) # увеличиваем на 1 
new_numbers2 = list(filter(lambda x: x%2 == 0, numbers)) # только четные

print(new_numbers1, new_numbers2, sep='\n') 
```
2. Замыкание
```python
def generator_square_polynom(a, b, c):
	return lambda x: a*x**2 + b*x + c
	
```
3. Использование тернарного оператора (и только их)
```python
numbers = [-2, 0, 1, 2, 17, 4, 5, 6] 
result = list(map(lambda x: 'even' if x % 2 == 0 else 'odd', numbers)) 

print(result)
```


all() - проверяет коллекцию на отсутствие False
any() - проверяет коллекцию на присутствие True

**`all(iterable)`**

- ищет `False`, и если находит хотя бы одно, то возвращает `False.` Если все элементы `True` - возвращаете `True` .

`print(all([])) # передаем пустой список` выводит: `True`

`print(all(())) # передаем пустой кортеж` выводит: `True`

`print(all('')) # передаем пустую строку` выводит: `True`

`print(all([[], []])) # передаем список, содержащий пустые списки` выводит: `False`,

`**any(iterable)**`

 - ищет `True`, и если находит хотя бы одно, то возвращает `True.` Если все элементы `False` - возвращаете `False.`

 `print(any([])) # передаем пустой список` выводит: `False`

`print(any(())) # передаем пустой кортеж` выводит: `False`

`print(any('')) # передаем пустую строку` выводит: `False`

`print(any([[], []])) # передаем список, содержащий пустые списки` выводит: `False`

Функции `all()` и `any()` могут быть полезны в комбинации с функцией `map()`, которая может преобразовывать элементы последовательности (итерируемого объекта) к значению `True/False` в соответствии с неким условием.

Например, 

все ли элементы списка `numbers` больше 10:

`result = all(map(lambda x: x > 10, numbers))`

хотя бы один элемент списка четное число:

`result = any(map(lambda x: x % 2 == 0, numbers))`

`**enumerate(iterable, start)**`

-  возвращает итератор из кортежей из индекса элемента и самого элемента переданной ей последовательности (итерируемого объекта).  `start`  - необязательный параметр,  задает начальное значение индекса. По умолчанию  `start = 0`  (счет начинается с нуля).

### **zip(*iterables)**

- объединяет элементы из каждого переданного ей итерируемого объекта в кортежи. Возвращает итератор из кортежей. Итоговую длину определяет объект с наименьшим количеством элементов.

Используется для создания словарей, когда ключи и значения находятся в разных списках.

`info = dict(zip(keys, values))`

удобна для одновременного (параллельного) итерирования сразу по нескольким коллекциям.

`for x, y in zip(name, age):`

`print(x, y)`

Можно использовать `zip()` и `enumerate()` одновременно.

`for index, (item1, item2) in enumerate(zip(list1, list2)):`

`print(index, item1, item2)`