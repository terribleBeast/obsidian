## Garbage Collector (GC) 


GC - процесс, который периодически освобождает память, удаляя из неё ставшие ненужными объекты.

## Python 

Сборщик мусора не работает в режиме реального времени, а работает периодически. Каждый запуск сборщика создает микропаузу в работе программы, поэтому Python использует различные [[Словарь/Эвристика|эвристики]] для определения частоты запуска сборщика мусора. 

Сборщик мусора разделяет все объекты на 3 поколения (нулевое, первое и второе). Новые объекты попадают в нулевое поколение. Если новый объект выживает в процессе сборки мусора, то он перемещается в следующее поколение. Чем старше поколение, тем реже оно сканируется на сборку мусора. Так как новые объекты могут быть "временными" переменными, следовательно, их нужно как можно быстрее удалить, нежели те, которые уже прошли несколько этапов сборки мусора.

В каждом поколении есть специальный порог срабатывания, при достижении которого срабатывает процесс сборки мусора. Если сразу несколько поколений преодолели порог, то выбирается наиболее старшее поколение, так как сборка мусора в старших поколениях включает в себя также сборки мусора и в младших поколениях.

Для взаимодействия со сборщиком мусора используется модуль `gc`/

Некоторые функции:
- `gc.enable()`: включает сборщика мусора (по умолчанию он включен)
- `gc.disable()`: отключает сборщика мусора
- `gc.isenabled()`: возвращает `True`, если сборщик мусора включен, или `False` в противном случае
- `gc.collect()`: запускает сборщика мусора на всех трех поколениях. Функция имеет необязательный аргумент `generation` (целое число от 00 до 22), указывающий номер поколения, в котором нужно запустить сборщика мусора

В Python GC является "второй линией обороны", первая - счетчик ссылок. 

Примечания:
    1. Документация [gc](https://docs.python.org/3/library/gc.html)
    2. Исходный код сборщика мусора [ссылка](https://github.com/python/cpython/blob/051295a8c57cc649fa5eaa43526143984a147411/Modules/gcmodule.c#L94)


# История

Создан Джоном Маккартни в 1959 в ЯП Лисп. В дальнейшим он применялся в других ЯП, приемущественно в функциональных и логических. Причина: неудобное отслеживание времени жизни объектов в памяти и ручное управление её, ввиду сложной структуры этих языков.  Широко используемые в таких языках списки и осноыванные на них сложные структуры данных во врем работы постоянно надстраиваются, расширяются, копируются и правильно определить момент удаления того или иного объекта проблематично. 

В промышленных процедурных и объектных языках сборка мусоры долго не использовалась, так как ручное управление памятью считалось более предсказуемым и эффективным. Но со второй половины 1980-х технология стала применяться  в императивных и объектных ЯП, а со второй половины 1990-ч годов всё большее число создаваемых языков и сред, ориентированных на прикладное программирование, включают механизм сборки мысора либо как единственный, либо как один из доступных механизмов управления динамической памятью. Примеры ЯП: C#, Ruby, Python, Go.

Дописать https://ru.wikipedia.org/wiki/Сборка_мусора Ручное управление памятью
