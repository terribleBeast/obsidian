Global Interpriter Lock - глобальная блокировка интерпретатора, которая позволяет только одному потоку выполнять байт-код Python в один момент времени.

Суть: всегда работает только один поток у процесса.
Аналогия: два потока машин и придурок, кидающий кирпич то на одну дорогу, то на другую, следовательно, всегда один из потоков будет стоять.

CPU-bound операции - операции, требующие большой вычислительной мощности процессора.

IO-bound операции - операции, при выполнении которых основным фактором, ограничивающим производительность, является скорость ввода/вывода (IO), а не процессор. При выполнении таких операций процессор ожидает их завершения, что снижает его производительность.

Повышения производительности с помощью многопоточности мы можем получить только при наличии IO-операций в коде.

Минусы GIL:
* ограниченность многопоточность
* Нельзя использовать несколько ядер
* Обработка сигналов (Ctrl + C) (из-за блокировки главного потока)
* Нестабильное время выполнения кода (переключение между потоками не регламентировано - [[Словарь/Квантование времени|квантование]]) 

Состояние гонки (Condition race)

Наступает, когда к одной переменной получают доступ два потока.
C версии 3.11 это исправили

Приме

``` python

import threading  
  
counter = 0  
  
  
def increment():  
    global counter  
    for _ in range(1000000):  
        counter += 1  
  
  
thread_1 = threading.Thread(target=increment)  
thread_2 = threading.Thread(target=increment)  
  
thread_1.start()  
thread_2.start()  
  
thread_1.join()  
thread_2.join()  
  
  
print(counter)

```

На версии 3.9 будут разные результаты 
На версии 3.11 будет правильный результат

Причина: += это не [[Словарь/атомарная операция|атомарная операция]]?? - нужно сначала прочитать данные, потом инкремент

Ресурсы:
https://habr.com/ru/companies/otus/articles/769448/
https://wiki.python.org/moin/GlobalInterpreterLock
https://habr.com/ru/companies/wunderfund/articles/586360/