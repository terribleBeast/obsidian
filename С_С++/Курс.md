из [курса](https://stepik.org/lesson/1191258/step/2?unit=1204229) 

![](приоритеты_операций_C.png)

![](спецификаторы_C.png)

## Булевый тип
В си нет булевого типа. Взамен его есть целочисленный определенный оператором \_Bool. Любое значении отличное от нуля приравнивается в единице. Чтобы использовать тип "нормальный" тип bool, нужно импортировать `stdbool.h`. В нем введены две константы true=1 и false=0. В Си используются ленивые логические операторы.

## Минимум / максимум
 (n1 + n2)/2-+ abs(n1-n2)/2 


## Оператор switch и ключевое слово break, default
Рекомендации по использованию switch:
- лучше выносить в отдельную функцию из-за большого объема строк
- программу следует организовать так, чтобы после каждой метки case прописывался вызов некоторой функции вместо набор операторов
- не использовать вложенный switch

## Побитовые операции ~, &, ^, |

Особенность XOR: отсутствует потеря данных, то есть при повторном применении мы получим то же значение.
 Где этот эффект можно применить? Самое простое – в шифровании данных. Например, когда у нас есть сообщение в виде набора данных и маска – как шифровальный ключ. Тогда, к каждому блоку данных можно применить маску и, таким образом, зашифровать сообщение. **В частности по такому принципу устроена защита по паролю в архиваторе zip**. Причем, сам пароль является ключом, который накладывается по XOR на заархивированные данные.
Побитовые сдвиги.

## Генерация псевдослучайных чисел. Функции математической библиотеки.

библиотека stdlib
Функции:

rand - возвращает значение, полученное алгоритмом, который генерирует их на основе начального значения - seed (состояния регистров) при запуске программы. Возвращает один и те же значения при каждом запуске программы. Значения распределены равномерно.

srand - позволяет изменить начальное значение seed - зерно

Чтобы каждый раз передавать разное значение зерна, используем функцию time, чтобы получить системное время

``` c
#include <time.h>
#include <stdlib.h>

srand(time(NULL))
```

## Директива \#define для определения макросов-функций. Операции # и \#\#

Ссылка на [тесты](https://stepik.org/lesson/1191282/step/2?unit=1204270)

> [!NOTE] 
> Действие макроопределений распространяется только на текущий модуль
> Макросы обрабатываются до выполнения программы, для них переменные не существуют

#### Определение макрос-функции
Макропроцессор просто подставляет выражение из директивы define в код, с переданными аргументами, ничего при этом не вычисляя.
Хорошая практика: заключать макрос и его аргументы в скобки, чтобы избежать возможных ошибок. 
``` c
#include <stdio.h>
 
#define SQ_PR(A, B)   ((A) * (B))
 
int main(void)
{
    int res = SQ_PR(2, 3);
    printf("res = %d\n", res);
 
    return 0;
}

```

#### Операции # и \#\#

Операция # возвращает текстовое представление лексемы, например параметра.
А теперь, как она работает. В макро-функции TEXT(A, B) у нас два параметра, а затем, идет тело макроса в виде пяти фрагментов строки. Первый фрагмент – это буквально та строка, что прописана. Второй фрагмент \#A формируется из представления параметра A, а он в нашем примере представляет собой выражение x-2. И это выражение преобразуется в обычную строку. И далее все остальные фрагменты. Все они соединяются в одну строку и формируют конечный результат макровызова TEXT(x-2, y-3).

``` c
#include <stdio.h>
 
#define SQ_PR(A, B)     ((A) * (B))
#define TEXT(A, B)     "Square of rectangle (" #A ") x (" #B ")\n"
 
int main(void)
{
    int res = SQ_PR(2, 3);
    printf(TEXT(x-2, y-3)); // Square of rectangle (x-2) x (y-3)\n
 
    return 0;
}
```

Операция ## служит для склейки выражений.

``` c
#include <stdio.h>
 
#define SQ_PR(A, B)     ((A) * (B))
#define TEXT(A, B)      "Square of rectangle (" #A ") x (" #B ")\n"
#define X_N(N)          x ## N
 
int main(void)
{
    int x1 = 1, x2 = -2, x4 = 10;
    printf("%d\n", X_N(4));
 
    return 0;
}
```

Принцип работы: в теле макро-функции X_N прописаны две лексемы: x и N, причем, вместо N подставляется переданное выражение 4. В итоге, вызов X_N(4) объединяет в единую лексему x4 выражение x и 4 и это эквивалент того, что мы в программе вместо X_N(4) прописали выражение x4, которое соответствует ранее объявленной целочисленной переменной.

## Директивы \#include и условной компиляции 

После обработки препроцессором вместо директивы \#include будет подставлено содержимое указанного файла на её место. 
Пример: файл stdio.h будет подставлен на место \#include <stdio.h>, но в этом файле не реализаций функций, а только её прототип. 

[Где находятся описания функций](https://stackoverflow.com/questions/42787130/function-definitions-of-built-in-functions-in-c)


> [!NOTE] Запись названий файлов
> Если нужно подключить стандартные файлы, поставляемые с компилятором языка Си, то следует писать угловые скобки. Если же подключаются свои собственные заголовочные файлы, то их имена следует заключать в двойные кавычки.

### Директивы условной компиляции 

Директивы: \#if, \#endif, \#elif, \#else, \#ifdef, \#ifndef, \#elifdef, \#elifndef

[Комментарий Meat Eflymas](https://stepik.org/lesson/1191283/step/6?unit=1204271)

Используются для подстановки фрагмента текста при определенном условии.

Например, пишется программа, которую предполагается компилировать с использованием компилятора C и C++. Так как в этих ЯП имеются некоторые отличия в используемых конструкциях и часть программного кода должна отличаться в зависимости от ЯП, поэтом, чтобы написать универсальный текст программы, можно воспользоваться условными директивами:

``` c
#define LANG_C
 
#if defined(LANG_C)
#   include <stdio.h>
#else
#   include <iostream>
#endif
 
int main(void)
{
         int x=5;
#ifdef LANG_C
         printf("%d\n", x);
#else
         std::cout << x << std::endl;
#endif
 
    return 0;
}
```

Dначале определено макроимя LANG_C с помощью директивы \#define. Затем, прописана директива \#if, в которой проверяется условие: определено ли макроимя LANG_C в текущем модуле. Если это так (как в нашем примере), то макропроцессор оставляет в программе все, что записано после этой директивы либо до следующей условной директивы, либо до директивы \#endif. В приведенном примере, остается строчка «#include <stdio.h>» и удаляется строка «#include <\iostream>». Соответственно, директива \#include также, затем, обрабатывается макропроцессором. В итоге, после обработки, у нас получается следующий текст программы:

``` c
#include <stdio.h>
 
int main(void)
{
         int x=5;
         printf("%d\n", x);
 
    return 0;
}
```

Разумеется, директива \#include здесь также впоследствии преобразуется макропроцессором. А директива \#ifdef – это сокращенный вариант записи конструкции \#if defined.

По сути, директивы условной компиляции \#if, \#else,\#endif работают подобно условным операторам if-else, о которых мы с вами уже говорили. Но, конечно же, есть и отличия. Первый важный момент: в условиях директив можно использовать исключительно целочисленные литералы и макроимена. С этими элементами можно выполнять все булевы операции сравнения:

\==, !=, <, >, <=, >=

логические связки:

&&, ||, !

все бинарные арифметические и битовые операции:

+, -, *, /, %, &, |, ^

и применять оператор defined, которые возвращает 1, если указанное макроимя существует и 0 – в противном случае. Есть еще несколько экзотических конструкций, вроде условной тернарной операции, которые допустимо прописывать в условиях директив, но в основном используются те операции, что перечислены выше. Обратите внимание, никаких переменных, функций и прочих конструкций, значение которых определяется в процессе работы программы, здесь применять нельзя.

Второй важный момент. Директивы условной компиляции не образуют своих собственных внутренних блоков. Поэтому для указания того, что попадает внутрь таких директив, в конце обязательно следует прописать директиву\#endif – метку, означающую конец текущей директивы условной компиляции.

Третий важный момент. Директивы препроцессора анализируют программу как текст (на уровне лексем). Это означает, что они не учитывают области видимости: локальные, глобальные и т.п. Поэтому все директивы принято записывать с самого начала строки (с левого края). В частности, именно поэтому символ # у директив include записан на одном уровне с другими директивами, т.к. никакого реального вложения здесь нет, и это мы подчеркиваем оформлением. То же самое при записи директив внутри функции main(). Для всех этих директив функции не имеют никакого значения – это просто текст. Поэтому все они прописаны с самого начала строки.

Зацита от повторного использования

Пример stdio.h будет содержать эти строчки

``` c
#ifndef _INC_STDIO
#define _INC_STDIO

// А ниже обязательно будет записана директива:

#endif
```

Когда файл stdio.h подключался первый раз, то макроимя \_INC_STDIO отсутствовало и условие директивы \#ifndef оказалось истинным, так как \#ifndef – это аналог \#if !defined. Раз условие истинно, то все, что определено до директивы \#endif включается в файл, в том числе и директива «#define \_INC_STDIO», которая определяет макроимя \_INC_STDIO. Теперь оно существует в текущем модуле. Это значит, при повторном включении файла stdio.h условие директивы \#ifndef окажется ложным и фрагмент дублироваться не будет.

## Указатели. Приведение типов. Константа NULL

``` c
char d = 5; 
char *gpt;   // объявление указателя для работы с данными типа char
gpt = &d;   // взятие адреса переменной d и присваивание его указателю gpt
char x = *gpt; // получение значения по адресу переменной d
*gpt = 100;  // запись значения в ячейку, где расположена переменная d
```
Указатель на уровне машинных кодов занимает место эквивалентное размеру целочисленной переменной (длине машинного слова):
* 4 байта - для 32-х разрядных систем
* 8 байтов - для 64-х разрядных систем

``` c
ptr = (char *)ptr_arg; // оператор приведения типов
```

Следует быть особо внимательным при использовании указателей разных типов в одном выражении. 
Примеры возможных ошибок:
``` C
#include <stdio.h>
 
int main(void) 
{
         int arg = 777;
         char *ptr;
         
         ptr = &arg;
        *ptr = 0; // arg = 768
        
         return 0;
}
```

Причина: char занимает 1 байт, мы присвоили переменной значение 0, то есть изменили 1 байт в памяти, но ptr указывает на первый байт в переменной arg, следовательно, также изменит её значение.

> [!NOTE] Применение указателей 
> Указатели используются, когда необходим прямой доступ к любой заданной точке памяти с возможность. игнорирования областей видимости.


Тип *void\** введен для работы с указателями. Таким указателям можно присваивать другие указатели, но нельзя читать значениях, так как не понятно как интерпретировать значения. 

### Арифметика указателей 

Значение указателя меняется на размер типа данных, для которого он определен.

Все операции выполняются с целыми числами

Поддерживаемые операции:
1. Сложение (не указателей)
2. декремент
3. Инкремент
4. Разность указателей 
Запрещенные:
1. Умножение 
2. Деление 

Примеры 
``` c
int main(){
    int a = 5, b = 7;
    double d = 2.0;
    int* ptr_a = &a, *ptr_b = &b;

    ptr_a += 3; //да
    ptr_b += ptr_a; //нет, так как не имеет смысла
    ptr_a *= a; // нет  
    --ptr_a; // да
    ptr_b++; // да
    ptr_a += b * 5; // да
    ptr_a -= d; // нет
    ptr_a /= b; // нет
    ptr_b -= ptr_a; // нет, так как переменные не обязательно указывают на последовательные участки памяти, то вычитание может привести к неопределенности.
    ptr_b + ptr_a; // нет
    ptr_b - ptr_a; // да, для вычисления расстояния между указателями
}
```


## Массивы

Массив - последовательность байт определённого типа в памяти 
В C нет структуры данных массив, так как массив в C это просто фрагмент области памяти.
Формула вычисления первого байта: $$adress\_k\ =\ f\ +\ k\ *\ size,\ k\ =\ 0,1,\ \dots\ ,\ n-1$$ `f` - номер первого байта первого элемента в памяти устройства
`size` - размер одного элемента в памяти(например, для char  это 1 байт)

$$
size\_array\ =\ size\_element\ *\ size\_array
$$
Объявление массива: \<type> \<name>\[size];
``` c
#define SIZE_BUFFER          1024
 
int main(void)
{
         // Корректные объявления
         double f[30];
         char buffer[SIZE_BUFFER];
         int marks[13];
         short ar[8 * 5];
         char bytes[sizeof(double)];
 
         // Некорректные объявления
         int n = 5;
 
         float func[21.5];   // вещественное количество элементов
         int array[n];       // нельзя было до стандарта C99
         int null_ar[0];     // размер должен быть больше нуля
 
         return 0;
}
```
Возможность использовать целочисленные переменные для задания размера массива появилась в C99, а так же понятие массивов переменной длины, размеры которых можно определять через целочисленные переменные. Однако не все последующие стандарты C поддерживают такой способ объявления, или определяют его как необязательный. Поэтому использование переменных при объявлении массивов стоит избегать, чтобы избежать проблем при переносимости. 

При выходе за пределы массива, не все компиляторы предупредят об этом, так как отвечать за это должен программист. При обращении к индексу, выходящему за границу массива, или к индексу, значение которого не задано, то, скорее всего, мы получим мусор.

### Вычисление размера массива 

``` c
size_t size_marks = sizeof(marks) / sizeof(*marks);
printf("%zu");
```

Тип `size_t` это переопределение целочисленного безногого типа (обычно unsigned long long). Он введен для универсальной записи программ при использовании функция или операций подобной `sizeof`.  
### Инициализация массивов

``` c
#define TOTAL 5

int main()
{
    int m[TOTAL] = {0, 1} // остальные значения будут установлены инициализатором и равны нули (использование инициализатора может тормозить программу) 
    int m2[] = {0, 2, 3} // без указания размера, он будет равен числу элементов
    int m1[TOTAL] = {[2] - 3, [3] = 0} // остальные нули
}
```

### Указатели на массивы
``` c
int main()
{
    short m[] = {1, 2, 3, 5};
    short ptr_m = m; // хорошо

    for(int i = 0; i < sizeof(ar) / sizeof(*ar); ++i)
        printf("%d ", *(ar+i));
    
}
```

Указатель на массив это не простой указатель. [Прочесть](https://habr.com/ru/articles/251091/)
Отличия:
- операция `sizeof` для указателя на массив вернет число байт, которое он занимает в памяти;
- адрес указателя на массив формируется в момент его объявления (размещения в памяти устройства) и остается неизменным на протяжении работы программы.

## Ключевое слово `const` с указателями и переменными 

``` c
#include <stdio.h>

int main()
{
    // указатель, значение которого нельзя менять (адрес можно)
    const short *ptr_ar; 
    ptr_ar = ar;
    ptr_ar[0] = 10; // ошибка
    ptr_ar ++; // доступно
    short x2 = *ptr_ar; // доступно
    
     // указатель с неизменным адресом ()
    short * const ptr_ar = ar; 
    ptr_ar = ar; // нет
    ptr_ar++; // нет
    ptr_ar[0] = 10 // да
    x2 = ptr_[0]; //да
    
    return 0;
}
```

``` c
#include <stdio.h>

int main()
{
    short ar[] = {4, 3, 2, 1, 5, 6, 7};
    const short * ptr_1 = ar;
    short * ptr_2 = ar;
    // ptr_1 - читать, ptr_2 - читать и менять.

    // допустимо, так как кл. слово накладывает ограничение только на указатель, а не на ячейку памяти.
    ptr_2[0] = 10;
    int a = ptr_1[0];

    // нельзя!
    short *ptr_3 = ptr_1;
    
    return 0;
}
```


> [!NOTE] `const` для компилятора
> Ключевое слово `const` значимо только для компилятора, то есть в машинный код оно не переводится

Ключевое слово `const` значимо только для компилятора, на уровен машинных кодов первый и второй указатели идентичны. Именно компилятор при трансляции программы котролирует корректность использованя указателя с ключевым словом `const`. В данном случае, компилятор контролирует, чтобы не происходило записи в ячейку память с помощью указателя `ptr_1` (иначе выдаст ошибку).

Часто можно встретить при объявлении глобальных массивов.
``` c
#include <stdio.h>

const int marks[] = {1, 2};

int main()
{
    return 0;
}
```

### `const` с переменными

переменная, объявленная с `const`, не является литералом (значение определяется во время выполнения программы). Поэтому такие переменные нельзя использовать в операторе `switch`.

Однако такие переменные можно использовать при объявлении массивов.  Однако, так делать не рекомендуется, так как машинный код программ может получаться крайне неэффективным. Поэтому лучше использовать макросы. 

``` c
#include <stdio.h>

#define SIZE 13

int main()
{
    const int code = 13;
    char str[code]; //нет
    char str[SIZE]; // да
    return 0;
}
```

## Операции с массивами: копирование, вставка, удаление, сортировка

копирование только через поэлементное присваивание
Вставка - сдвиг вправо
Удаление - сдвиг влево
Сортировка приведена "Вставка"