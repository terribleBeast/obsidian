# Компьютерные системы: архитектура и программирование 
### *Рэндал Э. Брайант Дэвид Р. О'Халларон*

Третье издание, 2022 год

##### О чем:
В книге описываются стандартные элементы архитектуры, такие как  центральный процессор, память, порты ввода-вывода, а также ОС, компилятор, компоновщик и сетевое окружение. Представлены способы представления данных и программ на машинном уровне, приемы оптимизации программ, особенности управления потоками выполнения и виртуальной памятью, а также методы сетевого и параллельного программирования. Приведенные в виде промеры для процессоров, совместимых с Intel (x86_64), написаны на [языке C](Язык_программирования_C.md) и выполняются в ОС Linux. 

Материалы из книги: [ссылка](csapp.cs.cmu.edu)
Приложение: [csapp.cs.cmu.edu](https://csapp.cs.cmu.edu/3e/waside.html)

## Обзор:

### [Глава 1. Экскурс в компьютерные системы.](Глава_1._Экскурс_в_компьютерные_системы..md).
#### Описание: 
Описаны основные идеи и темы. относящиеся к компьютерным системам, на примере исследования жизненного цикла простой программы "hello, world".

### Глава 2. Представление информации и работа с ней.
Представление чисел в компьютере, работа с арифметическими операциями.

### Глава 3. Представление программ на машинном уровне
Изучение машинного кода x86-64, созданного компилятором C. А также здесь представлены основные шаблоны инструкций для различных управляющих структур, таких как условные операторы, циклы и операторы выбора. Рассмотрены реализации процедур, включая выделение места на стеке, условные обозначения использования реестров и передачу параметров. Описаны структуры данных. Будут показаны программы с точки зрения машины, что поможет понять распространенные уязвимости, такие как переполнение буфера, и шаги, которые программист, компилятор и ОС могут предпринять для уменьшения угроз.

### Глава 4. Архитектура процессора.
В этой главе описываются комбинаторные и последовательные логические элементы, после чего, демонстрируется как эти элементы можно объединить в информационный канал, выполняющий упрощенный набор инструкций x86-64, с названием "Y86-64". Сначала будет рассматриваться однотактный тракт данных. Его архитектура проста, но не отличается высоким быстродействием. Затем будет рассмотрена конвейерная обработка, в которой различные шаги, необходимые для обработки инструкции, реализуются как отдельные этапы. Получившийся в результате пятиступенчатый процессорный конвейер немного более реалистичнее. Управляющая логика процессора описывается с использованием простого языка описания аппаратных средств - **HCL**.. Проекты аппаратного обеспечения, написанные на HCL, можно компилировать и объединять в симуляторы, а затем использовать для создания описания Verilog.

Вопросы: 
1. что такое HCL

### Глава 5. Оптимизация производительности программ.
В этой главе представлен ряд методов повышения производительности кода, учитывая, что программы написаны на C так, чтобы компилятор мог затем сгенерировать эффективный машинный код. Сначала рассмотрены преобразования сокращающие объем работы, который предстоит выполнить программе. Затем будут продемонстрированы преобразования повышающие степень параллелизма на уровне команд в сгенерированном машинном коде, чтобы повысить их производительность на современных "суперскалярных" процессорах. Для обоснования этих преобразований будет представлена простая модель работы современных процессоров и показано, как измерить потенциальную производительность программы с точки зрения критических путей с использованием графического представления программы.

Вопросы: 
1. "Суперскалярные" компьютеры это ...
2. Так ли эффективны описанные оптимизации?

### Глава 6. Иерархия памяти.
В главе рассматриваются типы памяти: ОЗУ, ПЗУ, а также геометрические параметры и устройство существующих современных дисковых накопителей, организация этих запоминающих устройств в иерархию.  Авторы показывают память как "гору памяти" со "скалами" временной локальности и "склонами" пространственной локальности.  В заключении рассказывается, как повысить производительность программных приложений путем усовершенствования их временной и пространственной локальности. 

Вопросы:
1. Что такое временная и пространственная локальность?
2. В чем заключается идея взгляда "гора памяти"?

## Глава 7. Связывание.
В данной главе описывает статическое и динамическое связывание, включая такие понятия, как: перемещаемые и выполняемые объектные файлы, разрешение символов, перемещение, статические библиотеки, разделяемые библиотеки, перемещаемый код и подмены библиотечных функций. Причины рассмотрения данной темы: из-за незнания этой темы на этапе связывания возникают ошибки (особенно в крупных проектах); тема объектных файлов связана с такими понятиями, как загрузка, виртуальная память и отображение памяти.

Вопросы:
1. Что такое связывание?
## Глава 8. Управление исключениями.
Ввод ==концепции "потока управления исключениями"== (не совпадающего с обычным потоком управления путем ветвления в условных операторах и в точках вызова процедур). Будут рассмотрены примеры потоков управления исключениями, существующих на всех уровнях системы, от аппаратных исключений и прерываний низкого уровня до переключений контекста между параллельными процессами, внезапных изменений в потоке управления, вызванных передачей сиuналов Linux, и нелокальных переходов в C, разрывающих стройную структуру стека. 
Будет представлено фундаментальное понятие **процесса** как абстракции выполняющейся программы.  Здесь будет рассмотрена работа процесса, их создание и управление исходя из прикладных программ. 

Вопросы:
1. В чем заключается суть концепции "потока управления исключениями"?
2. Что такое "процесс"?

## Глава 9. Виртуальная память.
 Описание виртуальной памяти и принципов её работы. Здесь будет рассказано о процессах, действующих одновременно, которые могут использовать один и тот де диапазон адресов, совместно использовать одни страницы памяти и иметь индивидуальные копии других. Будет рассмотрено управление виртуальной памятью и манипулирование её. Обсуждение данной темы необходимо, чтобы избежать ошибок обращения к памяти в программах (утечки памяти и недействительные ссылки в указателях). Наконец, многие программисты реализуют свои инструменты распределения памяти, оптимизированные под требования и характеристики конкретного приложения. Эта глава в большей степени демонстрирует неразрывную связь между аппаратными и программными аспектами компьютерных систем.

Вопросы: 
1. Что такое виртуальная память?
2. Как с ней взаимодействовать? 
3. Как эффективно её использовать?

## Глава 10. Системный уровень ввода/вывода.
Рассмотрены концепции ввода/вывода в системе Unix, такие как файлы и [дескрипторы](Словарь/Дескриптор). Авторы описывают совместное использование файлов, принципы работы переадресации ввода/вывода и доступ метаданным файлов. Будет представлен пример разработки надежного пакета буферизованного ввода/вывода для демонстрации поведении подсистем ввода/вывода, известным как [*недостача*](Словарь/Недостача). В главе демонстрируется стандартная библиотека ввода/ввода языка C и её связь с подсистемой ввода/вывода в Linux с упором на ограничения стандартного ввода/вывода, делающие его непригодным для сетевого программирования.

Вопросы:
1. Принцип работы недостачи.
2. Как обеспечить доступ к метаданным файлов?
3. Почему стандартный поток ввода/вывода не пригоден для сетевого программирования?

## Глава 11. Сетевое программирование.
Сети является своеобразными устройствами ввода/вывода для программ, объединяющими многие из понятий, описанных ранее: процессы, сигналы, порядок следования байтов, отображения памяти и динамическое распределение пространства запоминающих устройств. Данная глава - лишь тонкий срез глобального предмета сетевого программирования, необходимый для создания простенького веб-сервера. Здесь будет представлена модель клиент-сервер, лежащая в основе всех сетевых приложений. Авторы представят взгляд программиста на сеть Интернет и покажут, как писать сетевые клиенты и серверы, используя интерфейс сокетов. И наконец, в главе будет представлен [протокол HTTP](Компьютерные сети/протокол HTTP) и разработан простой веб-сервер.

Вопросы:
1. Что такое сетевое программирование?
2. Как писать сетевой клиент?
3. Что такое сокет?
4. Описание модели клиент-сервер.

## Глава 12. Конкурентное программирование.
Эта глава описывает принципы конкурентного (параллельного) программирования на примере сетевого сервера. Авторы сравнивают и противопоставляют три основных механизма, используемых для создания конкурентных программ: процессы, мультиплексирование ввода/вывод и потоки выполнения - и показывают возможность их использования при создании серверов, способных обслуживать множество одновременных соединений. Здесь же описаны основные принципы синхронизации с использованием семафорных операций *P* и *V* , безопасность потоков выполнения и реентерабельность, а также состояние взаимоблокировки. Конкурентное программирование играет важную роль в большинстве сетевых приложений. Также в этой главе описывается конкурентное программирование на уровне потоков выполнения, что позволяет ускорить решение задач на многоядерных процессорах. Чтобы все ядра правильно и эффективно работали над одной вычислительной задачей, требуется тщательная координация потоков, выполняющихся конкурентно (параллельно).

Вопросы:
1. Принципы конкурентного программирования.
2. Что такое мультиплексирование?
3. Что такое семафорные операции?
4. В чем заключается реентерабельность?
5. Как правильно настроить ядра для эффективной?
