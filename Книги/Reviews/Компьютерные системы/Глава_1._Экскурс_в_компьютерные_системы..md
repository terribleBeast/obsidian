
**Компьютерная система** - состоит из аппаратных средств и программного обеспечения, которые взаимодействуют, обеспечивая слаженное выполнения прикладных программ.  


## 1.1 Информация - это биты и контекст

Программа на C хранится, как последовательность байт, представляющих двоичное представление кода символа по таблице ASCII. Это иллюстрирует одну из фундаментальных идей: вся информация хранится, как последовательность бит. Но стоить помнить, что трактование двоичного представления символа зависит от контекста, в котором оно применяется.  

## 1.2 Программы, которые переводятся другими программами в различные формы

Программа hello[^1] начинает свою жизнь как программа на языке высокого уровня. Однако, чтобы запустить программу hello.c в системе, [оператор](Оператор.md) на языке C должны быть преобразованы другими программами в некоторую последовательность инструкций на машинном языке низкого уровня. Эти инструкции затем упаковываются в выполняемую объектную программу (выполняемый объектный файл) и сохраняются в двоичном файле на диске. 

Трансляция исходного файла выполняется в четыре этапа:

1. **Этап препроцессора** (этап предварительной обработки). Препроцессор (cpp) выполняет все директивы, используемые в исходном файле (include - вставляет внешней файл в исходный)
2. **Этап компиляции.** Компилятор (ccl) [транслирует](Трансляция.md) текстовый файл hello.i в текстовый файл hello.s, который содержит *программу на языке ассемблера.* 
3. **Этап ассемблирования**. Ассемблер (as) транслирует файл hello.s в машинные инструкции, упаковывает их в форму, известную как *перемещаемый объектный код*, и запоминает результат в объектном файле hello.o. Файл hello.o - это двоичный файл, содержащий 17 байт, которые кодируют машинные инструкции, составляющие функцию main. 
4. **Этап компоновки**. В программе hello вызывается функция printf, которая поставляется в комплекте с любым компилятором языка C. Функция printf находится в отдельном предварительно скомпилированном файле с именем printf.o, который тем или иным способом должен быть объединён с нашей программой hello.o. Это объединение осуществляет компоновщик (ld). В результате получается выполняемый объектный файл (или просто выполняемый файл), готовый к загрузке и выполнению системой. 
![[Система компиляции.png]]

## 1.3 Как происходит компиляция

Научимся писать эффективный код.
Темы: 
- Оптимизация производительности программы. 
	- Получим ответы на вопросы: 
		- Всегда ли `swtch` эффективнее `if-then-else`?; 
		- Какие накладные расходы несет вызов функции?
		- Какой способ обращения к элементам массива эффективнее - по указателю или по индексам?
		- Почему цикл выполняется намного быстрее, если накапливать сумму в локальной переменной вместо аргумента, который передается по ссылке?
		- Можно ли ускорить функцию, если просто расставить круглые скобки в арифметическом выражении?
		- Как компиляторы транслируют различные конструкции языка C в этот язык?
- Понимание ошибок времени компоновки
	- Вопросы:
		- Что означает сообщение компоновщика о том, что он не может разрешить ссылку?
		- Чем различаются статические и глобальные переменные? 
		- Что случится, если в разных файлах на C объявить две глобальные переменные с одинаковыми именами? 
		- Чем отличаются статистические и динамические библиотеки? 
		- Почему важен порядок перечисления библиотек в командной строке? 
		- Почему ошибки, источником которых является компоновщик, остаются незаметными до выполнения программы? 
* Как избежать прорех в системе защиты
		Изучение особенностей хранения в программном стеке данных и управляющей информации. Будет показано, как правильно использовать стек и избежать уязвимостей, порождаемых переполнением буфером. Будут описаны методы, которые могут быть использованы для снижения угрозы атак.

## 1.4 Процессоры читают и интерпретируют инструкции, хранящиеся в памяти
[Командная_оболочка](Командная_оболочка.md)
[Устройство компьютера](Статьи/Компьютер)

#### Выполнение программы hello
1. В [командную оболочку](Командная_оболочка.md) поступают символы `./hello`, командная оболочка прочитает каждый их них в регистр и сохранит в основной памяти. Когда мы нажнем Enter, оболочка воспримет это как сигнал окончания ввода команды. После этого она загрузит выполняемый файл `hello`, ощуствив последовательность инструкций, которая скопирует в основную память программные коды и данные, содержащиеся в объектном файле `hello` на диске. Данные включают строку символов "hello, world\\n", которая в конечном итоге будет выведена на экран. 
![](чтение_команды_с_клавиатуры.png)
2. Используя метод, называемый прямой доступ к памяти (Direct Memory Access, DMA, см главу 6), данные перемещаются с диска непосредственно в оперативную память, минуя процессор.
![](загрузка_файла_в_основную_память.png)
3. Как только код и данные из объектного файла `hello` будут загружены в память, процессор начинает выполнять машинные инструкции подпрограммы main в программе `hello`. Эти инструкции дают команду копировать байт строки "hello, world\\n" из основной памяти в регистры, а оттуда - на дисплей, на экране которого они затем отображаются. 
![](вывод_строки_на_дисплей.png)

## 1.5 Различные виды кеш-памяти 

Целью создания кэш-памяти является увеличение производительности устройства (программ, выполняющихся на этих устройствах). Порывом к этому служит нежелательное
## 1.6 Устройства памяти образуют иерархию
## 1.7 Операционная система управляет работой аппаратных средств

Фундаментальные абстракции ОС: процессы, виртуальная память, файлы.
## 1.8 Обмен данными в сетях
## 1.9 Важные темы. 

Закон Амдала: повышение производительности системы зависит не только от повышения эффективности одной её части, но и насколько значимой она является
## 1.10 Итоги

### Сноски

[^1]:  Программа "Hello, world!":
	```c++
		#include <stdio.h> 
	
		int main() 
		{
			printf("hello, world\n"); 
			return 0;
		}

