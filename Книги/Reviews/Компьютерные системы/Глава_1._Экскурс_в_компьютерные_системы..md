
**Компьютерная система** - состоит из аппаратных средств и программного обеспечения, которые взаимодействуют, обеспечивая слаженное выполнения прикладных программ.  


## 1.1 Информация - это биты и контекст

Программа на C хранится, как последовательность байт, представляющих двоичное представление кода символа по таблице ASCII. Это иллюстрирует одну из фундаментальных идей информатики: вся информация хранится, как последовательность бит. Но стоит помнить, что трактование двоичного представления символа зависит от контекста, в котором оно применяется.  

## 1.2 Программы, которые переводятся другими программами в различные формы

Программа hello[^1] начинает свою жизнь как программа на языке высокого уровня. Однако, чтобы запустить программу hello.c в системе, [оператор](Оператор.md) на языке C должны быть преобразованы другими программами в некоторую последовательность инструкций на машинном языке низкого уровня. Эти инструкции затем упаковываются в выполняемую объектную программу (выполняемый объектный файл) и сохраняются в двоичном файле на диске. 

> [!TODO]
> Протестировать усё это в MS Visual Studio. А вдруг врут?

Трансляция исходного файла выполняется в четыре этапа:

1. **Этап препроцессора** (этап предварительной обработки). Препроцессор (cpp) выполняет все директивы, используемые в исходном файле (include - вставляет внешней файл в исходный)
2. **Этап компиляции.** Компилятор (ccl) [транслирует](Трансляция.md) текстовый файл hello.i в текстовый файл hello.s, который содержит *программу на языке ассемблера.* 
3. **Этап ассемблирования**. Ассемблер (as) транслирует файл hello.s в машинные инструкции, упаковывает их в форму, известную как *перемещаемый объектный код*, и запоминает результат в объектном файле hello.o. Файл hello.o - это двоичный файл, содержащий 17 байт, которые кодируют машинные инструкции, составляющие функцию main. 
4. **Этап компоновки**. В программе hello вызывается функция printf, которая поставляется в комплекте с любым компилятором языка C. Функция printf находится в отдельном предварительно скомпилированном файле с именем printf.o, который тем или иным способом должен быть объединён с нашей программой hello.o. Это объединение осуществляет компоновщик (ld). В результате получается выполняемый объектный файл (или просто выполняемый файл), готовый к загрузке и выполнению системой. 
![[Система компиляции.png]]

## 1.3 Как происходит компиляция

Научимся писать эффективный код.
Темы: 
- Оптимизация производительности программы. 
	- Получим ответы на вопросы: 
		- Всегда ли `swtch` эффективнее `if-then-else`?; 
		- Какие накладные расходы несет вызов функции?
		- Какой способ обращения к элементам массива эффективнее - по указателю или по индексам?
		- Почему цикл выполняется намного быстрее, если накапливать сумму в локальной переменной вместо аргумента, который передается по ссылке?
		- Можно ли ускорить функцию, если просто расставить круглые скобки в арифметическом выражении?
		- Как компиляторы транслируют различные конструкции языка C в этот язык?
- Понимание ошибок времени компоновки
	- Вопросы:
		- Что означает сообщение компоновщика о том, что он не может разрешить ссылку?
		- Чем различаются статические и глобальные переменные? 
		- Что случится, если в разных файлах на C объявить две глобальные переменные с одинаковыми именами? 
		- Чем отличаются статистические и динамические библиотеки? 
		- Почему важен порядок перечисления библиотек в командной строке? 
		- Почему ошибки, источником которых является компоновщик, остаются незаметными до выполнения программы? 
* Как избежать прорех в системе защиты
		Изучение особенностей хранения в программном стеке данных и управляющей информации. Будет показано, как правильно использовать стек и избежать уязвимостей, порождаемых переполнением буфером. Будут описаны методы, которые могут быть использованы для снижения угрозы атак.

## 1.4 Процессоры читают и интерпретируют инструкции, хранящиеся в памяти
[Командная_оболочка](Командная_оболочка.md)
[Устройство компьютера](Статьи/Компьютер)

#### Выполнение программы hello
1. В [командную оболочку](Командная_оболочка.md) поступают символы `./hello`, командная оболочка прочитает каждый из них в регистр и сохранит в основной памяти. Когда мы нажнем Enter, оболочка воспримет это как сигнал окончания ввода команды. После этого она загрузит выполняемый файл `hello`, осуществив последовательность инструкций, которая скопирует в основную память программные коды и данные, содержащиеся в объектном файле `hello` на диске. Данные включают строку символов "hello, world\\n", которая в конечном итоге будет выведена на экран. 
![](чтение_команды_с_клавиатуры.png)
2. Используя метод, называемый прямым доступом к памяти (Direct Memory Access, DMA, см главу 6), данные перемещаются с диска непосредственно в оперативную память, минуя процессор.
![](загрузка_файла_в_основную_память.png)
3. Как только код и данные из объектного файла `hello` будут загружены в память, процессор начинает выполнять машинные инструкции подпрограммы main в программе `hello`. Эти инструкции дают команду копировать байт строки "hello, world\\n" из основной памяти в регистры, а оттуда - на дисплей, на экране которого они затем отображаются. 
![](вывод_строки_на_дисплей.png)

## 1.5 Различные виды кеш-памяти 

Целью создания кеш-памяти является увеличение производительности устройства (программ, выполняющихся на этих устройствах). Порывом к этому послужили слишком большие временные затраты на перемещение данные из одного места в другое.

> [!Intresting]
> В силу физических законов, чем больше запоминающее устройство, тем медленнее оно работает. В то же время создание быстродействующих запоминающих устройств обходится дороже, чем более медленных

По мере развития полупроводниковых технологий расхождения в скорости доступа к регистрам и к основной памяти продолжают углубляться.
Увеличить быстродействие процессора намного проще, чем заставить основную память работать быстрее. 

Кеш-память - устройство хранения данных в процессоре, служащее для временного хранения информации, которая, возможно понадобиться процессору в будущем. 

##### Уровни кеш-памяти:
- Keш L1 (кеш первого уровня) хранить внутри процессора десятки тысяч байт, доступ  осуществляется почти так же быстро, как к регистрам.
- Kеш L2 вмещает от сотни тысяч до миллиона байт. Связан с процессором специальной шиной. Скорость доступа к кешу L2 в 5 раз ниже скорости доступа к кешу L1, но она в 5-10 раз выше скорости доступа к основной памяти. 

==L1 и L2 построены по технологии: статистическая память с произвольным доступом (Static Random Access Memory, SRAM)==

Современные системы могут иметь больше уровней кеша.

Идея кеширования: дать системе доступ к большому объему памяти с минимальными временными затратами, использую [локальность](Локальность.md).


## 1.6 Устройства памяти образуют иерархию

Чем ниже устройство, тем устройства становятся медленнее, объемнее, а стоимость одного байта уменьшается.

Основная идея: память одного уровня служит кешем для следующего нижнего уровня. То есть блок регистров - это кеш для L1. 

![Иерархия памяти](иерархия_памяти.png)
## 1.7 Операционная система управляет работой аппаратных средств

Все программы взаимодействуют между собой используя операционную систему. Любые операции с аппаратными средствами прикладные программы должны выполнять через ОС. 

![](организация_комп_сис.png)

Требования к ОС: защищать аппаратные средства от ошибок других программ; предоставлять простой и единообразные механизмы манипулирования сложными и часто сильно отличающимися низкоуровневыми аппаратными средствами.

Фундаментальные абстракции ОС: процессы, виртуальная память, файлы.

#### Процессы 
![процесса](Процесс.md) 
В одной и той же системе может выполняться множество процессов, но каждому процессу "кажется", что только он пользуется аппаратными средствами. Под *одновременным* (или параллельным) выполнением мы понимаем поочередное выполнение инструкций то одного, то другого процесса.

Традиционные системы могут выполнять только одну программу, но современные многоядерные процессоры способны одновременно выполнять программный код нескольких программ. Чтобы достичь эффекта "одновременности" выполнения программ процессор переключается между выполнением одной программы, на другую. Операционная система проделывает такое чередование с помощью механизма *переключения контекста*.

[Контекст](Контекст.md)
Когда ОС принимает решение передать управление некоторому другому процессу, она производит *переключение контекста*, запоминая контекст текущего процесса и восстанавливая контекст нового, после чего передает управление новому процессу. Новый процесс возобновляет выполнение точно с того места, в котором был прерван.

Пример работы механизма переключения контекстов.

Изначально было два процесса: процесс командной оболочки и процесс `hello`. Первоначально ОС выполняла только один процесс командной оболочки. Когда мы обращаемы к нему с требованием запустить программу `hello`, оболочка выполняет наше требование, вызывая специальную функцию - **системный вызов**, которая передает управление ОС. ОС сохраняет [контекст](Контекст.md), создает новый процесс `hello` с его контекстом, а затем система восстанавливает контекст процесса оболочки и возвращает ему управление, и он снова ждет ввода следующей команды.

![Переключение контекстов процессов](переключение_контекстов_процессов.png)

Переключение с одного процесса на другой производится [ядром](Ядро_ОС.md) операционной системы.

Например

Когда прикладная программа требует от ОС какого-либо действия, к примеру чтения из файла или записи в файл, она выполняет специальную инструкцию системного вызова, передавая управление ядру. Затем ядро выполняет запрошенную операцию и возвращает управление прикладной программе. 

> [!Важно]
> Ядро не процесс, а блок кода и структур данных, которые система использует для управления всеми процессами.

#### Потоки 

![Поток](Поток.md)

Роль потоков как программных моделей непрерывно возрастает в связи с требованиями к поддержке параллельных вычислений, предъявляемыми сетевыми серверами, поскольку организовать совместное использование данных несколькими потоками намного проще, чем несколькими процессами, а также в силу того, что потоки обычно значительно эффективнее процессов. Кроме того, многопоточность является одним из способов ускорить работу программ, когда в системе имеется несколько процессоров.

Дописать статью об Unix

#### Виртуальная память

![[Словарь/Виртуальная память|Виртуальная память]]

Виртуальное адресное пространство для процессов ОС Linux (Unix-системы используют ту же топологию). В системах Linux верхняя часть адресного пространства резервируется для программного кода  данных ОС, которые являются общими для всех процессов. В нижней части адресного пространства находятся программный код и данные, принадлежащие процессам пользователей (программ). Адреса нумеруются снизу вверх.

![](модель_виртуального_адресного_пространства_процесса.png)

Виртуально адресное пространство, с точки зрений каждого процесса, состоит из некоторого числа четко определенных областей, каждый из которыз выполняет свою функцию.
Области:
- **Программный код и данные.** Программный код каждого процесса всегда начинается с одного и того же адреса, за ним следуют ячейки памяти, соответствующие глобальным переменным. Область с кодом и данными инициализируется непосредственно содержимым выполняемого объектного файла, в нашем случае `hello`. (глава 7)
- **Динамическая память (куча).** Далее за кодом и данным следует область кучи программы. В отличие от предыдущей области, которой фиксируется, как только процесс начнет выполняться, динамическая память может расширяться и сокращаться в размерах во время выполнения программы, при вызову некоторых функций их стандартной библиотеки C, таких как `malloc` и `free`. (глава 9)
- **Совместно используемы (разделяемые) библиотеки.** Ближе к середине адресного пространства находится область с программным кодом и данными *совместно используемых библиотек*, таких как стандартная библиотека C или библиотека математических функций. (глава 7)
- **Стек.** В верхней части виртуального пространства находится *стек пользователя*, который применяется компилятором для реализации вызовов функций. Как и динамическая память, стек пользователя может динамически расширяться и сокращаться в размерах во время выполнения программы. В частности, каждый раз, когда программа вызывает какую-либо функцию, размер стека увеличивается. Каждый раз, когда функция возвращает управление стек сокращается. (глава 3)
- **Виртуальная память ядра.** Верхняя часть адресного пространства зарезервирована для ядра. Прикладным программам запрещено читать содержимое этой области, записывать в ней данные или напрямую вызывать функции ядра.

==Разобраться== 
Основная идея заключается в том, чтобы сохранить содержимое виртуальной памяти процесса на диске, а затем использовать основную память как кеш диска. (глава 9)

#### Файлы

![Файл](Файл.md)
Простая структура файла обеспечивает комфортное взаимодействие между программами любых типов.
## 1.8 Обмен данными в сетях

С пришествием глобальных сетей, таких как интернет, копирование информации между машинами стало одним из наиболее важных применений компьютерных систем. 
[FTP](FTP.md)
#### Как выполняется программа на удаленной машине с помощью telnet?

После регистрации на удаленной машине запустится удаленная командная оболочка, которая будет ждать от нас ввода команд. 
После ввода строке `hello` на стороне клиента и нажатия клавиши Enter клиент отправит эту строку telnet-серверу. Когда сервер получит эту строку из сети, он передаст её командной оболочке. Затем оболочка запустит программу `hello` и передаст выходную строку telnet-серверу. Наконец, telnet-сервер перешлет полученную строку клиенты по сети, а тот отобразит её на локальном дисплее.  (глава 11)

## 1.9 Важные темы. 

### Закон Амдала

Закон Амдала: повышение производительности системы зависит не только от повышения эффективности одной её части, но и насколько значимой эта часть является.

![](формула_амдала.png)

### Конкуренция и параллелизм

Конкуренция - общий термин для выполнения множества действий.
Параллелизм - использование конкуренции для ускорения системы.

Конкуренция может использоваться на нескольких уровнях абстракции:

##### Конкуренция на уровне потоков
Основываясь на абстракции процессов, разрабатывались системы, в которых несколько программ выполняются одновременно, что приводит к конкуренции. Используя механизм потоков, можно запустить несколько потоков управления в рамках одного процесса. 

Поддержка конкурентного выполнения появлялась в компьютерных системах с момента появления механизма разделения времени в начале 1960-х годов, . В те года конкурентное выполнении только моделировалось - компьютер просто быстро переключался между выполняемыми процессами. Эта форма конкуренции позволяет нескольким пользователям одновременно взаимодействовать с системой.  Например, она дает возможность одному пользователю открыть несколько окон приложений. Если все действия выполняет один процесс - это конфигурация известна как *однопроцессорная системы*.

Когда в системе имеется несколько процессоров - это *многопроцессорная система*. Они были доступны для крупномасштабных с 1980-х годов. Но с появлением технологии[гиперпоточности](Гиперпоточность.md) и [многоядерных процессоров](Многоядерный_процессор.md) они стали обычным явлением.  

Классификация систем:
- Однопроцессорные
- Многопроцессорные
	- Многоядерные процессоры
	- Процессоры с поддержкой гиперпоточности

[Гиперпоточность](Гиперпоточность.md)

Преимущества технологии многопроцессорной обработки:
- уменьшение необходимости моделирования конкуренции при выполнении нескольких задач;
- дает возможность выполнять каждый отдельную прикдажную программу быстрее, при условии того, что в ней имеется несколько потоков управления, способных эффективно выполняться параллельно. 

Принципы параллелизмы формировались и изучались на протяжении 50 лет, только появление многоядерных и гиперпоточных систем способствовало появлению желания использовать приемы разработки прикладных программ, используемых эти технологии.

#### Параллелизм на уровне инструкций

> [!note]
> Параллелизм на уровне инструкций - свойство, заключающиеся в выполнении нескольких инструкций за такт процессора.


 Например, процессору Intel 8086 1978 года для выполнения одной инструкции требовалось несколько тактов (3-10). Современные процессоры могут выполнять по 2-4 инструкции за такт. Для выполнения любой конкурентной инструкции требуется намного больше времени (20 тактов), но процессор использует ряд хитрых приемов для одновременной обработки до 100 инструкций. 
 
> [!note]
> Конвейерная обработка - метод выполнения инструкций, в котором инструкции делятся на этапы, а аппаратное обеспечение процессора организовано в виде последовательнос тадий, каждый из которых выполняет один из этапов. Стадии могут работать параллельно, обрабатывая разные части инструкций. (глава 4)

[[Словарь/Процессор|Суперскалярные процессоры]]

#### Одиночный поток команд, множественный поток данных

![[Словарь/SIMD]]

Подробнее в главе 5

### Важность абстракций в компьютерных системах

![Архитектурный_набор_команд](Архитектурный_набор_команд.md)

![[Словарь/Виртуальная_машина]]

## 1.10 Итоги

Компьютерные системы состоят из аппаратных и программных средств, которые взаимодействуют с целью выполнения прикладных программ.
Информация представлена в виде групп битов, которые интерпретируются в зависимости от контекста. 
Программы транслируются другими программами в различные формы. Сначала они представлены в виде исходного текста [ASCII](Кодировки.md), а затем преобразуются компиляторами и компоновщиками в выполняемые файлы.

Процессоры читают и интерпретируют двоичные инструкции, находящиеся в основной памяти. Поскольку большую часть времени компьютеры тратят на копирование данных между основной памятью, устройствами ввода/вывод и регистрами процессора, то память системы образует иерархию, на вершине которой находятся регистры процессора, далее следуют несколько уровней аппаратной кеш-памяти, затем основная DRAM-память и дисковая память. Чем выше находится устройство памяти в иерархии, тем выше его быстродействие и стоимость в пересчете на один бит. Кроме того, устройства памяти, находящиеся выше в иерархии, служат кешем для устройства памяти, находящихся ниже. 

Ядро ОС играет роль посредника между прикладными программами и аппаратными средствами. Оно реализует три фундаментальные абстракции:
    1) файлы, абстрагирующие устройства ввода/вывода
    2) виртуальную память, абстрагирующую как основную память, так и дисковую
    3) процессы, абстрагирующие процессоры, основную память и устройства ввода/вывода
Сеть для компьютера не что иное, как устройство ввода/вывода

### Сноски

[^1]:  Программа "Hello, world!":
	```c++
		#include <stdio.h> 
	
		int main() 
		{
			printf("hello, world\n"); 
			return 0;
		}

